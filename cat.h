#ifndef CAT_H
#define CAT_H

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <stdarg.h>
#include "cat.tab.h"  // Use the tokens generated by Bison

#define MAX_SYMBOLS 1000
#define MAX_ID_LENGTH 255

// Symbol types
typedef enum {
    SYM_VARIABLE,
    SYM_FUNCTION,
    SYM_PARAMETER
} SymbolType;

// Data types
typedef enum {
    TYPE_INT,
    TYPE_FLOAT,
    TYPE_VOID,
    TYPE_STRING,
} DataType;

// Symbol table entry
typedef struct SymbolEntry {
    char name[MAX_ID_LENGTH];
    SymbolType symType;
    DataType dataType;
    int scope;
    union {
        int intValue;
        float floatValue;
    } value;
    int initialized;
} SymbolEntry;

// Node types for AST
typedef enum {
    NODE_PROGRAM,
    NODE_FUNCTION,
    NODE_BLOCK,
    NODE_IF,
    NODE_SWITCH,
    NODE_CASE,
    NODE_IMPORT,
    NODE_VARDECL,
    NODE_ASSIGNMENT,
    NODE_BINARY_OP,
    NODE_UNARY_OP,
    NODE_CALL,
    NODE_CONSTANT,
    NODE_IDENTIFIER,
    NODE_BREAK,
    NODE_EXERT,
    NODE_CALL_BLOCK,
    NODE_FOR_LOOP,
    NODE_WHILE_LOOP,
} NodeType;


// AST node structure
typedef struct ASTNode {
    NodeType type;  // The type of the node (e.g., NODE_CONSTANT, NODE_IDENTIFIER, NODE_OPERATION, etc.)
    union {
        // For constants
        struct {
            DataType dataType;  // Data type of the constant (e.g., int, float, string)
            union {
                int intValue;
                float floatValue;
                char *stringValue;
            };
        } constant;

        // For function call with block
        struct {
            struct ASTNode *call;   // The function call node
            struct ASTNode *block; // The associated block node
        } callBlock;

        // For identifiers
        struct {
            char name[MAX_ID_LENGTH];  // Name of the identifier
            int symbolIndex;           // Symbol table index
            DataType dataType;         // Data type of the identifier
            union {
                int intValue;
                float floatValue;
            } value;  // To hold initialized value
            int hasInitializer;        // Indicates if the variable is initialized
            struct ASTNode *initializer; // Initializer expression node
        } identifier;

        // For operators
        struct {
            int operator;              // Operator type (e.g., +, -, *, /)
            struct ASTNode *left;      // Left operand
            struct ASTNode *right;     // Right operand
        } operation;

        // For function calls
        struct {
            char name[MAX_ID_LENGTH];  // Function name
            struct ASTNode **arguments; // Array of argument nodes
            int argCount;              // Number of arguments
        } call;

        // For control structures
        struct {
            struct ASTNode *condition;   // Condition node (e.g., in if, while)
            struct ASTNode *thenBranch; // Then-branch node
            struct ASTNode *elseBranch; // Else-branch node (optional)
        } control;

        // For for-loops
        struct {
            struct ASTNode *init;       // Initialization expression
            struct ASTNode *condition; // Condition expression
            struct ASTNode *increment; // Increment expression
            struct ASTNode *body;      // Loop body
        } forLoop;

        // For while-loops
        struct {
            struct ASTNode *condition; // Condition expression
            struct ASTNode *body;      // Loop body
        } whileLoop;

    } data;

    struct ASTNode *next;  // For linking nodes in statement lists or argument lists
} ASTNode;

// Symbol table
extern SymbolEntry symbolTable[MAX_SYMBOLS];
extern int symbolCount;
extern int currentScope;

// Function prototypes
void initSymbolTable(void);
int addSymbol(const char *name, SymbolType symType, DataType dataType, int scope);
int lookupSymbol(const char *name, int scope);
void freeAST(ASTNode *node);
ASTNode *createNode(NodeType type);
ASTNode *createBinaryOp(int operator, ASTNode *left, ASTNode *right);
ASTNode *createUnaryOp(int operator, ASTNode *operand);
ASTNode *createConstant(DataType type, ...);  // Uses varargs
ASTNode *createIdentifier(const char *name);
ASTNode *createNodeWithBlock(NodeType type, ASTNode *callNode, ASTNode *blockNode);
void executeAST(ASTNode *node) ;
void printSymbolTable() ;
void evaluateBlock(ASTNode *node);
void printWhileLoop(ASTNode *node, FILE *outFile) ;
void printForLoop(ASTNode *node, FILE *outFile);
void evaluateWhileLoop(ASTNode *node);
ASTNode *createForLoop(ASTNode *init, ASTNode *condition, ASTNode *increment, ASTNode *body);
void evaluateIfStatement(ASTNode *node);
void evaluateForLoop(ASTNode *node);
void evaluateSwitchStatement(ASTNode *node);
ASTNode *createForLoopNode(ASTNode *init, ASTNode *condition, ASTNode *increment, ASTNode *body);
ASTNode *createWhileLoopNode(ASTNode *condition, ASTNode *body);


// Add this to cat.h
float evaluateExpression(ASTNode *node);
ASTNode *createConstantString(const char *value) ;
void printAST(ASTNode *node, FILE *outFile);
void yyerror(const char *s);

#endif // CAT_H
